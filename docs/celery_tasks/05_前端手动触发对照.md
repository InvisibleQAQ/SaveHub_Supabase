# 05｜前端手动触发 vs Celery 定时任务（对照表）

你的预期是：“前端按钮手动触发的任务”与“Celery 定时任务”逻辑一致。

但**目前代码现状并不完全一致**：RSS 手动刷新主要在前端直接解析 RSS，并没有进入 Celery 的完整链路。

---

## A. RSS 刷新：当前不一致

### 1）前端“Refresh Feed / Refresh All”做了什么

入口示例：
- `frontend/components/sidebar/feed-item.tsx`（右键菜单 Refresh Feed）
- `frontend/components/feed-refresh.tsx`（侧边栏顶部按钮 / Ctrl+R）

实际执行：

1. `POST /api/backend/rss/parse`（后端同步解析 RSS）
2. 前端把返回的文章写入 store，并 `POST /api/backend/articles` 入库
3. 更新 feed 的 `lastFetched/lastFetchStatus`（前端写入 feeds 表）

这条路径**不会自动触发**：

- `process_article_images`（图片处理）
- `process_article_rag`（RAG 分块 + embedding）
- `extract_article_repos`（文章仓库提取）

### 2）Celery 刷新做了什么

后端 Celery `refresh_feed / refresh_feed_batch` 的完整链路是：

RSS → 保存 articles → 图片处理 chord → RAG 调度 → repo extraction →（可能触发 repo sync）

详情见：
- `02_RSS刷新链路.md`
- `03_图片处理与RAG链路.md`
- `04_仓库提取与同步.md`

### 3）如何让两者一致（推荐方案）

让前端按钮不再直接 parse，而是调用后端队列接口：

- `POST /api/backend/queue/schedule-feed`（`force_immediate=true`）

对应后端会走 Celery：

- `refresh_feed(queue=high)` → 后续链路自动执行

这样“手动刷新”和“定时刷新”就能复用同一套后端逻辑。

---

## B. 仓库同步：基本一致，但实现有两套

前端“Sync repositories”按钮：

- 调用 `POST /api/repositories/sync`，这是一个 **SSE 长连接**，在 API 路由里直接做同步工作并推送进度（不是 Celery task）。

而 Celery 里也有：

- `sync_repositories` 任务（支持 auto/manual trigger），并且会在任务结束后调度下一次（1 小时后）。

两套实现的核心步骤相似（抓 starred / README / AI / openrank / embedding），但运行方式不同：

- SSE 版：适合前端展示实时进度。
- Celery 版：适合后台自动跑、失败重试、解耦 UI。

如果希望“手动同步”和“自动同步”也完全走同一个实现，需要做一次“统一入口”的重构（例如：手动触发也只负责创建 Celery 任务 + 用 task_id 轮询进度）。

