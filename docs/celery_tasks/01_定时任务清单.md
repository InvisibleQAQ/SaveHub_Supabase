# 01｜定时任务清单

这里的“定时任务”包含两类：

1. **Celery Beat 周期任务**：固定频率触发（真正意义上的 cron）。
2. **任务自我调度（countdown）**：任务执行完后，自己再安排下一次（更像“延迟队列 + 循环”）。

> 任务定义入口：`backend/app/celery_app/celery.py`（`beat_schedule`）

---

## A. Celery Beat 周期任务（固定频率）

> 这些任务不会直接干“重活”，而是做扫描/编排，然后把真正的处理任务丢进队列。

| 任务名 | 频率 | 作用 | 后续会调度哪些任务 |
|---|---|---|---|
| `scan_due_feeds` | 每分钟 | 扫描哪些 RSS feed 到时间该刷新了 | `schedule_user_batch_refresh` → `refresh_feed_batch`（并行）→ `schedule_batch_image_processing` → `process_article_images`（并行）→ `process_article_rag`（错峰） |
| `scan_pending_rag_articles` | 每 30 分钟 | **兜底**：扫描漏掉/失败的 RAG 文章 | `process_article_rag`（错峰） |
| `scan_pending_repo_extraction` | 每 30 分钟 | **兜底**：扫描漏掉的“文章仓库提取” | `extract_article_repos`（错峰） |

对应源码：
- `backend/app/celery_app/tasks.py`：`scan_due_feeds`
- `backend/app/celery_app/rag_processor.py`：`scan_pending_rag_articles`
- `backend/app/celery_app/repo_extractor.py`：`scan_pending_repo_extraction`

---

## B. 自我调度的“准定时任务”（countdown）

| 触发点 | 任务名 | 下一次调度 | 备注 |
|---|---|---|---|
| RSS 刷新完成后 | `refresh_feed` | `schedule_next_refresh()` 计算 `refresh_interval` 后，用 `countdown` 再次投递 `refresh_feed` | 这是“单 feed 模式”的自动刷新方式 |
| 仓库同步完成后 | `sync_repositories` | `schedule_next_repo_sync()` 固定 1 小时后再投递 `sync_repositories` | 手动同步也会重置 1 小时计时 |

对应源码：
- `backend/app/celery_app/tasks.py`：`schedule_next_refresh`
- `backend/app/celery_app/repository_tasks.py`：`schedule_next_repo_sync`

---

## C. 如何启用 Beat（重要）

要让 **A 类任务**真正按频率运行，需要单独启动 Celery Beat（只允许 1 个实例，避免重复调度）：

```bash
cd backend
celery -A app.celery_app beat --loglevel=info
```

同时还需要 worker：

```bash
cd backend
celery -A app.celery_app worker --loglevel=info --queues=high,default
```

备注：根目录 `package.json` 目前只有 `pnpm celery`（worker），没有包含 beat 的脚本。

