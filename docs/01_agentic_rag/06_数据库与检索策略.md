# 数据库与检索策略（基于 all_embeddings）

## 1. 当前数据基础（可直接复用）

你现有 `all_embeddings` 具备：

- `article_id` / `repository_id` 互斥
- 向量维度固定 `1536`
- 已建 `ivfflat` 索引
- `search_all_embeddings` 函数已返回 article + repository 字段

这意味着：**Agentic-RAG V1 不需要先改表结构即可落地。**

---

## 2. Tool 设计与 SQL 映射

## Tool: `search_embeddings`

- 依赖：`search_all_embeddings`
- 输入：query + top_k + min_score
- 输出：标准化 source 列表（前端卡片可直接使用）

## Tool: `expand_context`

当前无 parent store，可用两种方案：

### 方案A（推荐）邻域扩展

- 针对命中 source，按同 `article_id/repository_id`
- 拉取 `chunk_index` 相邻片段（如 ±2）
- 形成扩展上下文

### 方案B 同源二次语义检索

- 在同 `article_id/repository_id` 范围内二次向量搜索
- 适合 query 长、主题不连续场景

## Tool: `retrieve_parent_chunks`

为适配参考项目的 parent-child 检索思路，在不改库结构前提下动态构造父块：

- parent_id 格式：`<source_type>:<source_id>:<start_chunk>:<end_chunk>`
- 先由 `search_embeddings` 返回 child 命中并标注 `parent_id`
- 再按 `parent_id` 一次性回溯较大 chunk 区间并合并为父块证据

该方案让现有 `all_embeddings` 也能覆盖“先精确召回 child，再补充 parent 上下文”的流程。

---

## 3. 索引建议（可选优化）

如果后续数据量增长明显，可考虑：

- 增加 `all_embeddings(user_id, article_id, chunk_index)`
- 增加 `all_embeddings(user_id, repository_id, chunk_index)`

用于邻域扩展时快速定位相邻 chunk。

---

## 4. 引用编号生成策略

聚合多个子问题时，要避免重复 source 造成编号混乱：

1. 建立 `source_key`：
   - article: `article:<article_id>:<chunk_index>`
   - repo: `repo:<repository_id>:<chunk_index>`
2. 全局去重
3. 按最终出现顺序分配 `index=1..N`
4. 在答案文本中统一替换 `[ref:old] -> [ref:new]`

---

## 5. 后续V2升级点（非本次必须）

若你后续追求更强“上下文完整性”：

- 在 `all_embeddings` 增加 `parent_id`
- 新建 `parent_documents` 存父块全文
- 将当前动态 `retrieve_parent_chunks` 升级为持久化 parent store 查询

这会更贴近参考项目的 parent-child 形态。
