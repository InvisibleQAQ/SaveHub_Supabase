# 后端实施步骤（LangGraph + FastAPI + Supabase）

## 1. 文件级改造总览

### 新增文件（建议）

- `backend/app/services/agentic_rag_service.py`
- `backend/app/services/agentic_rag/__init__.py`
- `backend/app/services/agentic_rag/graph.py`
- `backend/app/services/agentic_rag/graph_state.py`
- `backend/app/services/agentic_rag/nodes.py`
- `backend/app/services/agentic_rag/edges.py`
- `backend/app/services/agentic_rag/tools.py`
- `backend/app/services/agentic_rag/prompts.py`
- `backend/app/schemas/agentic_rag_chat.py`
- `backend/app/api/routers/agentic_rag_chat.py`

### 修改文件

- `backend/app/main.py`（注册新路由）
- `backend/app/services/ai/clients.py`（新增 tool calling 能力）

### 可选移除（最终阶段）

- `backend/app/services/self_rag_service.py`
- `backend/app/api/routers/rag_chat.py`

---

## 2. ChatClient 扩展（关键前置）

你当前 `ChatClient` 只有普通 complete/stream，没有 tool call。

### 必加能力

1. `complete_with_tools(...)`
   - 入参：`messages`, `tools`, `tool_choice`, `temperature`, `max_tokens`
   - 返回：`assistant_message`（包含 `content` + `tool_calls`）

2. `complete_json(...)`（可选）
   - 用于 rewrite/split/analysis 的结构化输出

### 实现建议

- 直接基于 OpenAI-compatible `chat.completions.create` 的 `tools` 字段
- 先不依赖 langchain-openai 的工具层，避免双层抽象复杂度
- 对非工具模型返回做保护：若 tool_calls 为空可进入降级分支

---

## 3. Agent 图设计（LangGraph）

## 主图节点

1. `summarize_context`：压缩历史上下文（可选）
2. `rewrite_and_split`：改写为自包含问题，最多拆分3个
3. `clarification_gate`：不清晰则输出澄清问题并终止本轮
4. `dispatch_questions`：并发/顺序发送到子图
5. `aggregate_answers`：将子问题答案聚合成最终回复

## 子图节点（单问题）

1. `agent_reason`：触发 tool calling
2. `run_tools`：执行工具
3. `judge_enough`：是否继续检索/补全
4. `finalize_answer`：生成含 `[ref:N]` 的最终答案片段

## 边逻辑

- `rewrite_and_split -> clarification_gate`
- `clarification_gate`：
  - unclear -> `END`（发送 clarification 事件）
  - clear -> `dispatch_questions`
- 单问题子图循环：`agent_reason -> run_tools -> judge_enough -> (agent_reason | finalize_answer)`

---

## 4. 工具层设计（适配 all_embeddings）

## Tool-1: `search_embeddings`

- 输入：`query`, `top_k`, `min_score`
- 流程：
  - embedding client 生成 query vector
  - 调 `search_all_embeddings`
  - 标准化为统一 source 对象
- 输出：结构化 JSON（不要纯文本）

## Tool-2: `expand_context`

用于模拟 parent-chunk 补全，弥补当前没有 parent store。

- 输入：`seed_source_ids` / `seed_query` / `window_size`
- 方案（推荐）
  - 同 source 的 `chunk_index ± N` 邻域拉取
  - 或同 `article_id/repository_id` 下再做一次相似检索
- 输出：补充 source 列表

> 注意：该工具必须受上限保护（例如最多调用 2 次），防止循环扩张。

---

## 5. 严格“仅基于知识库”策略

在 `prompts.py` 中明确硬约束：

- 未检索到足够证据时，必须回答“知识库暂无相关信息”
- 禁止加入外部常识补全
- 每个关键论断后必须带 `[ref:N]`

并在聚合节点增加后验检查：

- 若回答不含任何 `[ref:N]` 且有检索来源，触发一次修正生成

---

## 6. 新路由实现

新增 `backend/app/api/routers/agentic_rag_chat.py`：

- 路径：`POST /api/agentic-rag/stream`
- 鉴权：沿用 `verify_auth`
- 配置：沿用现有 `ApiConfigService` 的 chat + embedding 配置
- 响应：`StreamingResponse(text/event-stream)`

SSE 事件类型请严格对齐 `05_SSE事件协议_v2.md`。

---

## 7. Self-RAG 下线建议（分两步）

1. 软下线：前端全部切新路由，旧路由保留1个版本窗口
2. 硬下线：删除 `rag_chat` router + `self_rag_service`

---

## 8. 参数初始推荐

- `top_k`: 8
- `min_score`: 0.35
- `max_tool_rounds_per_question`: 3
- `max_expand_calls_per_question`: 2
- `max_split_questions`: 3

参数可在 `09_待确认参数.md` 调整。

